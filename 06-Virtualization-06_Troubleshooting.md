## Домашнее задание к занятию "Домашнее задание к занятию "6.6. Troubleshooting"

__1.	Задача 1__

__Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.__

__Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.
Вы как инженер поддержки решили произвести данную операцию:__

__•	напишите список операций, которые вы будете производить для остановки запроса пользователя__

__•	предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB__

__Решение:__

1.1)	Определим с помощью команды *db.currentOp* запросы, которые в настоящее время выполняются на сервере. 

Пример:
```
db.currentOp()

{
    "inprog" : [
        {
            "opid" : "302616759",
            "active" : true,
            "secs_running" : 1,
            "microsecs_running" : NumberLong(1167662),
            "op" : "getmore",
            "ns" : "local.oplog.rs",
            "query" : {
                
            },
            ...
        },
        {
            "desc" : "conn48",
            "threadId" : "0x114c00700",
            "connectionId" : 48,
            "opid" : "mdss_shard00:302616760",
            "active" : true,
            "secs_running" : 1,
            "microsecs_running" : NumberLong(1169659),
            "op" : "getmore",
            "ns" : "local.oplog.rs"
            ...
        }
    ]
}
```
Атрибут *inprog* указывает, что запросы в настоящее время выполняются. Идентификатор *opid* запроса или операции. *secs_running* указывает время, в течение которого он был запущен. 

А вот такая команда вернет все запросы с длительностью более 3 секунд.
```
db.currentOp({"secs_running": {$gte: 3}})
```
Определив идентификатор запроса, можем принудительно его завершить:
```
db.killOp(302616759)
```

1.2)	Можно использовать *Database Profiler*. Профилировщик базы данных собирает подробные данные о запросах MongoDB, длина которых превышает определенный порог — порог в миллисекундах, при котором профилировщик базы данных считает запрос медленным. Профилировщик базы данных записывает все данные, которые он собирает, в *system.profile* коллекцию, чтобы мы могли проанализировать их позже.
Наиболее распространенной проблемой, наблюдаемой в этой области, является неэффективный план выполнения . MongoDB нужны правильные индексы для эффективного поиска по документам. Соответственно, чтобы не было долгих запросов, необходимо перестроить индекс.
___________________________________

__2.	Задача 2__

__Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.__

__Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и увеличивается пропорционально количеству реплик сервиса.__

__При масштабировании сервиса до N реплик вы увидели, что:__

__•	сначала рост отношения записанных значений к истекшим__

__•	Redis блокирует операции записи__

__Как вы думаете, в чем может быть проблема?__

__Решение:__

*Redis* хранит key-value значения в ОЗУ, соответственно, при лавинном росте новых данных, закончится и ОЗУ. Проблема – отсутствие свободных ресурсов ОЗУ.
___________________________________

__3.	Задача 3__

__Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей в таблицах базы пользователи начали жаловаться на ошибки вида:__

InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '

__Как вы думаете, почему это начало происходить и как локализовать проблему?__

__Какие пути решения данной проблемы вы можете предложить?__

__Решение:__

В целом, пути решение – правка параметров и создание индексов для ускорения запросов.
Более детально по параметрам:

•	1. Почему – объемные запросы, пути решения – увеличение значения параметра net_read_timeout.

•	2. Почему – малое значение параметра connect_timeout (клиент не успевает установить соединение). Пути решения – увеличение значения параметра connect_timeout.

•	3. Размер запроса превышает размер буфера max_allowed_packet (на сервере) или max_allowed_packet (на строне клиента). Пути решения – увеличение соотв. параметров.
___________________________________

__4.	Задача 4__

__Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.
После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:__

postmaster invoked oom-killer

__Как вы думаете, что происходит?__

__Как бы вы решили данную проблему?__

__Решение:__

Что происходит – потребности в памяти > чем (доступная память + подкачка)

Задача oom-killer заключается в том, чтобы пожертвовать одним или несколькими процессами, чтобы освободить память. Механизм *Out-Of-Memory Killer* завершает процесс *postmaster*, чтобы не упала система.

Пути решения – Добавить больше памяти (в противном случае настроить *swap*) либо произвести параметрические настройки в *Postgres*, соответствующие работе с памятью (например, *shared_buffer*, *work_mem*).
___________________________________
